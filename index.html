<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Nanotwttr</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Nanotwttr</h1>
      <h2 class="project-tagline">Jacob and Eden&#39;s NanoTwitter Project</h2>
      <a href="https://github.com/jacobcmurphy/nanotwitter" class="btn">View on GitHub</a>
      <a href="https://github.com/jacobcmurphy/nanotwitter/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jacobcmurphy/nanotwitter/tarball/master" class="btn">Download .tar.gz</a>
    </section>

<section class="main-content">
<h3>
<a class="anchor" href="#purpose"  aria-hidden="true"><span class="octicon octicon-link"></span></a>Purpose of the assignment</h3>
<p>
  This project was an assignment for COSI 105b at Brandeis University (Spring 2015). The purpose of the project
  was to make a simplified version of Twitter to practice concepts of scalability. This simplified Twitterr version
  has the ability to follow/unfollow people, view the tweets of the people that you follow, and to see both the 
  users that you follow and the users that follow you. Hashtags and mentions are not a part of the simple Twitter 
  project.
</p>
<p>
  To practice scalability, this project had us look at several things. Firstly, we started with the basics of 
  adding appropriate indices on the database tables. We also looked into the types of servers there are, such as 
  Unicorn and Puma. We also added in AJAX calls to give the appearance of a faster loading website - the framework of
  the page would appear, then the contents are added; that way the end user sees progress on page load. We then 
  added in Redis for caching to improve page load times.
</p>

<a href="screenshots.html">See screenshots of the project.</a>

<h3>
<a id="technology" class="anchor" href="technology" aria-hidden="true"><span class="octicon octicon-link"></span></a>Technologies</h3>

<h4>Physical Server</h4>
<p>
  For the sake of easiness, we started with a Heroku server (free version). This server had 512 MB of RAM
  and 1 CPU core. Near the end, we moved to a Digital Ocean droplet ($20/month). The purpose of this was 
  so we could have the app, database, and Redis all on the same machine to reduce the time caused by network latency.
  This layout is our inexpensive way of mimicking the server farm of a truly large scale application in which machines would be very close to each other to
  reduce the network latency.
</p>

<h4>Database</h4>
<p>
  We are using a Postgres database. The database has 3 main tables - users, followerships, and tweets.
  **EDEN**
</p>

<h4>Redis</h4>
<p>
  We are using a Redis instance on our DigitalOcean droplet. **EDEN**
</p>

<h4>Rack-based Server</h4>
<p>
  We are using the Puma webserver. Puma looked very promising based on several articles: 
  <ul>
    <li><a href="http://ylan.segal-family.com/blog/2014/05/13/unicorn-vs-puma-round-3/">Article 1</a></li>
    <li><a href="https://blog.codeship.com/puma-vs-unicorn/">Article 2</a></li>
    <li><a href="https://devcenter.heroku.com/changelog-items/594">Article 3</a></li>
  </ul>
</p>

<h4>Ruby and Sinatra</h4>
<p>
  We are using Ruby 2.1 on our server. We are also using the Sinatra framework to write routes
  and interact with our database and Redis instance. We decided to use the Sequel gem to interact with our
  database instead of using ActiveRecord. This gave us more granular control over the data and ensured
  that we knew what our queries were doing (and making sure we thought about avoiding the n+1 issue).
</p>

<h4>Testing</h4>
<p>
  We use <a href="https://loader.io/">loader.io</a> to load test the application. We also used New Relic 
  to get more detailed reports about bottlenecks in our system; New Relic was removed near the end due
  to the delays in load time that the metrics gathering caused.
</p>
<p>
  We are using minitest/spec and rack-test to write automated tests for our website.
  Minitest/spec appealed to us because of its simplicity and we heard good reports about its speed over rspec.
  Rack-test allows us to test our API endpoints by imitating requests to endpoints that Rack would handle.
</p>

<h4>Front End</h4>
<p>
  The front end uses AJAX to load the contents of the page after the framework of the page has been loaded. 
  This gives the user the feeling that the load speed is even faster than it actually is.
  **EDEN**
</p>

<h3>
<a id="engineering" class="anchor" href="#engineering" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interesting Engineering</h3>
<p>
  **EDEN**
</p>

<h3>
<a id="scalability" class="anchor" href="#scalability" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scalability</h3>
<p>
  
</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jacobcmurphy/nanotwitter">Nanotwttr</a> is maintained by <a href="https://github.com/jacobcmurphy">jacobcmurphy</a> and <a href="https://github.com/edenzik">edenzik</a>.</span>
        <span class="site-footer-date">Made 2015</span>
        <br>
        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

